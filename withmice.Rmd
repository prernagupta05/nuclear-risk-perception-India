---
title: "models with mice"
output:
  pdf_document:
    toc: yes
    toc_depth: 2
    keep_tex: yes
  header-includes:
  - \usepackage{dcolumn}
  - \usepackage{array}
  - "\\usepackage{placeins}"
  keep_md: yes
---


```{r load packages, warning = FALSE, message = FALSE, echo=FALSE}
  knitr::opts_chunk$set(warning = FALSE, message = FALSE)

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(lavaan))
suppressPackageStartupMessages(library(tsibble))
suppressPackageStartupMessages(library(DT))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(psych)) 
suppressPackageStartupMessages(library(foreign))
suppressPackageStartupMessages(library(MASS))
suppressPackageStartupMessages(library(Hmisc))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(naniar))
suppressPackageStartupMessages(library(mice))


```

```{r setup, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

moduletwo <- read_excel(here::here("thesis_surveydata/political_factors_complete.xlsx"))
module2 <- data.frame(moduletwo)
module2[module2 == "Rather not say/ Don't know"] <- "Rather not say/Don't know"



# loaded data set for module 2 eco -pol variables and removes the rows with question number and question text
```

```{r, eval =TRUE, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#This chunk contains the coding schemes of various scales used in survey one: eco-political factors, kahan scale and acceptance scale
codedmodule2 <- module2 %>%
  
#remove row 1
  filter(!row_number() %in% c(1,2)) %>% 
  
# replace risky likert scale with numbers
  mutate_at(vars(starts_with("Risky")), funs(case_when(. =="Not at all risky" ~ 1, 
                                                       . =="Slightly risky" ~ 2, 
                                                       . =="Moderately risky" ~ 3, 
                                                       . =="Very risky" ~ 4, 
                                                       . =="Extremely risky" ~ 5))) %>%

# replace beneficial likert scale with numbers  
  mutate_at(vars(starts_with("Ben")), funs(case_when(. =="Not at all beneficial" ~ 1,
                                                     . =="Slightly beneficial" ~ 2,
                                                     . =="Moderately beneficial" ~ 3,
                                                     . =="Very beneficial" ~ 4,
                                                     . =="Extremely beneficial" ~ 5 ))) %>%

# replace nuclear acceptance likert scale with numbers
  mutate_at(vars(N_accept,N_reluctantlyaccept,N_reject), funs(case_when(. == "Strongly disagree" ~ 1, 
                                                                        . == "Somewhat disagree" ~ 2,
                                                                        . == "Neither agree nor disagree" ~3,
                                                                        . == "Somewhat agree" ~ 4,
                                                                        . == "Strongly agree" ~ 5))) %>%
  
  
# code likert scale for variables for Kahan scale into numbers
  mutate_at(vars(starts_with (c("K_S","K_E","DISPLACE", "POLLUTE", "HEALTH", "JOBS", "BEAUTY", "PRIDE", "NPRIDE","DEV","PROSPER", "RELY"))), funs(case_when(. == "Strongly disagree" ~ 1, 
               . == "Somewhat disagree" ~ 2,
               . == "Neither agree nor disagree" ~3,
               . == "Somewhat agree" ~ 4,
               . == "Strongly agree" ~ 5))) %>%
  
# NO reverse code for likert scale for variables for Kahan scale into numbers
  mutate_at(vars(starts_with (c("K_H","K_I"))), funs(case_when(. == "Strongly disagree" ~ 1, 
                                                               . == "Somewhat disagree" ~ 2,
                                                               . == "Neither agree nor disagree" ~3,
                                                               . == "Somewhat agree" ~ 4,
                                                               . == "Strongly agree" ~ 5))) %>%

# code eco-pol scale variables into numbers
mutate_at(vars(SYSTEMDEMO,SYSTEMRELIGION,SYSTEMTECHNO,SYSTEMTOTAL,WEALTHLIM,MECHANISATION,DECISIONDECEN,INDUSTRYSMALL,ECONOMYLOCAL,ENVOVERDEV,OWNERPUB, OWNERREG), funs(case_when(. == "Strongly disagree" ~ 1, 
                        . == "Somewhat disagree" ~ 2,
                        . == "Neither agree nor disagree" ~3,
                        . == "Somewhat agree" ~ 4,
                        . == "Strongly agree" ~ 5))) %>%

# NO reverse code eco-pol scale variables into numbers 
 mutate_at(vars(DECISIONCEN,INDUSTRYLARGE,ECONOMYGLOBAL,OWNERPVT,OWNERNOREG), funs(case_when(. == "Strongly disagree" ~ 1, 
                                                                                                         . == "Somewhat disagree" ~ 2,
                                                                                                         . == "Neither agree nor disagree" ~3,
                                                                                                         . == "Somewhat agree" ~ 4,
                                                                                                         . == "Strongly agree" ~ 5))) %>%
  mutate_all(~ifelse(. == "Rather not say/ Don't know", "Rather not say/Don't know", .))%>%
  mutate_all(~ifelse(. == "West bengal", "West Bengal", .))%>%
  mutate_all(~ifelse(. == "WEST BENGAL", "West Bengal", .))%>%
  mutate_all(~ifelse(. == "Up", "Uttar Pradesh", .))%>%
  mutate_all(~ifelse(. == "Tamilnadu", "Tamil Nadu", .))%>%
  mutate_all(~ifelse(. == "UP", "Uttar Pradesh", .))
  



```



# Bar plot: STATE X PDEVELOP

```{r}

# Load necessary libraries
library(dplyr)
library(ggplot2)
library(forcats)

# Df to include relevant variables 

WBques <- module2 %>%  filter(!row_number() %in% c(1,2)) %>% dplyr::select(State, DISPLACENUCLEAR, HEALTHNUCLEAR, BEAUTYNUCLEAR, POLLUTENUCLEAR ) %>%
  mutate_all(~ifelse(. == "Rather not say/ Don't know", "Rather not say/Don't know", .))%>%
  mutate_all(~ifelse(. == "West bengal", "West Bengal", .))%>%
  mutate_all(~ifelse(. == "WEST BENGAL", "West Bengal", .))%>%
  mutate_all(~ifelse(. == "Up", "Uttar Pradesh", .))%>%
  mutate_all(~ifelse(. == "Tamilnadu", "Tamil Nadu", .))%>%
  mutate_all(~ifelse(. == "UP", "Uttar Pradesh", .))

levels_defined <- c("Strongly agree", "Somewhat agree","Neither agree nor disagree", "Somewhat disagree","Strongly disagree","Rather not say/Don't know")


WBques_factors <- WBques
WBques_factors[] <- lapply(names(WBques_factors), function(colname) {
  if (colname != "State") {
    factor(WBques_factors[[colname]], levels = levels_defined)
  } else {
    WBques_factors[[colname]] # Keep the State column unchanged
  }
})

WBques_factors$State <- factor(WBques_factors$State, 
                               levels = c("West Bengal", "Uttar Pradesh", "Maharashtra", "Rajasthan", "Tamil Nadu"))


library(dplyr)
library(ggplot2)

# Assuming your updated data frame is named WBques_factors

# Create a summary table with counts for each level of DISPLACENUCLEAR within each State
WBques_summary <- WBques_factors %>%
  count(State, DISPLACENUCLEAR) %>%
  group_by(State) %>%
  mutate(Proportion = n / sum(n))

# Create a named vector with full statements for each variable
full_statements <- c(DISPLACENUCLEAR = "Nuclear energy is leading to displacement of people from their land",
                     BEAUTYNUCLEAR = "Nuclear energy spoils the natural beauty of the landscape",
                     POLLUTENUCLEAR = "Nuclear energy increases pollution of air/water/land",
                     HEALTHNUCLEAR = "Nuclear energy poses a great risk to the health of people living around it",
                     ENVOVERDEV = "Polluting industries that spoil the environment should be shut down even if it costs people their jobs")

# Reshape the data to long format for the selected variables
WBques_long <- WBques_factors %>%
  pivot_longer(cols = c(DISPLACENUCLEAR, HEALTHNUCLEAR, BEAUTYNUCLEAR, POLLUTENUCLEAR),
               names_to = "Question",
               values_to = "Response") %>%
  mutate(Question = recode(Question, !!!full_statements)) # Replace var names with full statements

# Create a summary table with proportions for each level of Response within each State and Question
WBques_summary <- WBques_long %>%
  count(State, Question, Response) %>%
  group_by(State, Question) %>%
  mutate(Proportion = n / sum(n))

# Define the color sequence, with the darkest red for "Strongly agree"
colorsequence <- c("#8C4646","#D9695F","#F2A679","#F2D091","#FFF2CC","#808080")

# Plot the graph with facets for each Question
ggplot(WBques_summary, aes(x = State, y = Proportion, fill = factor(Response, levels = rev(levels_defined)))) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = rev(colorsequence), name = NULL) +
  facet_wrap(~ Question, scales = "free_y", ncol = 1) +
  coord_flip() +
  labs(x = "State", y = "Proportion", title = "Proportion of Responses by State for Nuclear energy related questions") +
  theme_minimal() +
  theme(
    # Increase the size of the main title
    plot.title = element_text(size = 16, face = "bold"),
    # Increase the size of the axis titles
    axis.title = element_text(size = 14),
    # Increase the size of the facet strip text
    strip.text.x = element_text(size = 12),
    # Adjust text angle for State labels if necessary
    axis.text.y = element_text(angle = 0)
  )

```


# barplot of demographics 


```{r, echo=FALSE}

library(dplyr)
library(tidyr)


demobar <- codedmodule2 %>% 
  dplyr::select("State", "Language", "age", "urban_rural", "gender", "caste" ,"religion") %>%
              mutate_all(~ifelse(. == "Rather not say/ Don't know", "Rather not say/Don't know", .))%>%
              mutate_all(~ifelse(. == "OBC", "Other Backward Classes (OBC)", .))%>%
              mutate_all(~ifelse(. == "SC", "Scheduled caste (SC)", .))%>%
              mutate_all(~ifelse(. == "ST", "Scheduled tribe (ST)", .))%>%
              mutate_all(~ifelse(. == "MAR", "Marathi", .))%>%
              mutate_all(~ifelse(. == "TA", "Tamil", .)) %>%
              mutate_all(~ifelse(. == "EN", "English", .))%>%
              mutate_all(~ifelse(. == "BN", "Bengali", .))%>%
              mutate_all(~ifelse(. == "MAR", "Marathi", .))%>%
              mutate_all(~ifelse(. == "HI", "Hindi", .))%>%
              na.omit()

#changing factor levels for each variable from high to low n 

demobar$State <- factor(demobar$State, levels = c("Rajasthan", "Maharashtra","West Bengal" , "Tamil Nadu", "Uttar Pradesh"))
demobar$Language <- factor(demobar$Language, levels = c("Hindi","Marathi","Bengali","Tamil", "English"))
demobar$age <- factor(demobar$age, levels = c( "18-24 years old" ,  "25-34 years old","35-44 years old", "45-54 years old", "55-64 years old","65-74 years old","75 years or older"  ))
demobar$urban_rural <- factor(demobar$urban_rural, levels = c("Rural","Urban"))
demobar$gender <- factor(demobar$gender, levels = c("Male","Female"))
demobar$caste <- factor(demobar$caste, levels = c("Scheduled tribe (ST)", "Scheduled caste (SC)", "Other Backward Classes (OBC)", "General","Brahmin","Rather not say/Don't know"))
demobar$religion <- factor(demobar$religion, levels = c("Hinduism", "Islam", "Christanity","Buddhism","Agnostism/ Atheism","Other (Please mention)"))


```

```{r, echo=FALSE, fig.width=11, fig.height=14, out.width='80%', out.height='80%'}

# Loading the required libraries
library(tidyverse)
library(gridExtra)
library(scales)

# Function to create bar plot
create_bar_plot <- function(data, variable_name, palette_name) {
  factor_levels <- levels(demobar[[variable_name]])
  data %>%
    filter(Variable == variable_name) %>%
    mutate(Category = factor(Category, levels = factor_levels)) %>%
    ggplot(aes(y = "", x = Percentage, fill = Category)) +
    geom_bar(position = "fill", stat = "identity", width = 1) +
    geom_text(aes(label = paste0(round(Percentage, 0), "%")), 
              position =  position_fill(vjust = 0.5)) +
    scale_x_continuous(labels = percent) +
    labs(y = NULL, x = "Percentage", fill = variable_name) +
    theme_classic() +
    theme(axis.text.y = element_blank(), strip.text = element_text(size = 10), legend.position = "top") +
    scale_fill_brewer(palette = palette_name)
}

# Gather data to long format and calculate counts and percentages
df_barplot <- demobar %>%
  gather(Variable, Category) %>%
  group_by(Variable, Category) %>%
  filter(!is.na(Category)) %>%
  summarise(n = n()) %>%
  mutate(Percentage = n / sum(n) * 100)

# Create separate plots for each variable
plot_state <- create_bar_plot(df_barplot, "State", "Spectral")
plot_language <- create_bar_plot(df_barplot, "Language", "Paired")
plot_age <- create_bar_plot(df_barplot, "age", "Set3")
plot_urban_rural <- create_bar_plot(df_barplot, "urban_rural", "Dark2")
plot_gender <- create_bar_plot(df_barplot, "gender", "Pastel1")
plot_caste <- create_bar_plot(df_barplot, "caste", "Set1")
plot_religion <- create_bar_plot(df_barplot, "religion", "Set2")

# Combine the plots with spacing
combined_plot <- gridExtra::arrangeGrob(plot_state, plot_language, plot_age, plot_urban_rural, plot_gender, plot_caste, plot_religion, ncol = 1, heights = c(1, 1, 1, 1, 1, 1, 1))

# Print the combined plot
grid::grid.newpage()
grid::grid.draw(combined_plot)

```




# Can do something with accept, reject and reluctantly accept. 

```{r, echo=FALSE}

## Can do something with accept, reject and reluctantly accept. 

n_acceptreject<- module2 %>%
                dplyr::select("N_accept", "N_reluctantlyaccept", "N_reject")

summary(n_acceptreject)
```

# missing data pattern and MCAR

```{r, echo=FALSE}


formice1 <- codedmodule2[, grep("State|age|urban_rural|gender|caste|religion|Solar|SOLAR|Nuclear|NUCLEAR|Coal|COAL|K_S|K_E|K_H|K_I|WEALTHLIM|MECHANISATION|DECISIONDECEN|INDUSTRYSMALL|ECONOMYLOCAL|ENVOVERDEV|DEVOVERENV|OWNERPUB|OWNERREG|DECISIONCEN|INDUSTRYLARGE|ECONOMYGLOBAL|OWNERPVT|OWNERNOREG", names(codedmodule2))]%>%
        dplyr::select(-c("Language", "Risky_INDSolar", "Ben_INDSolar", "religiontext")) %>%
          mutate(across(age, ~factor(.x, ordered = TRUE)))%>%  
          mutate(across(urban_rural:religion, ~factor(.x, ordered = FALSE)))%>%
          mutate(across(State, ~factor(.x, ordered = FALSE))) %>%
          mutate(Uppercaste = ifelse(caste %in% c('Brahmin', 'General'), 1, 0)) %>%
          mutate(Male = ifelse(gender == 'Male', 1, 0))%>%
          mutate(Hindu = ifelse(religion == 'Hinduism', 1, 0))%>%
          mutate(Age = case_when(
                                  age == "18-24 years old" ~ 1,
                                  age == "25-34 years old" ~ 2,
                                  age == "35-44 years old" ~ 3,
                                  age == "45-54 years old" ~ 4,
                                  age == "55-64 years old" ~ 5,
                                  age == "65-74 years old" ~ 6,
                                  age == "75 years or older" ~ 7))
  

#dplyr:: select(starts_with (c("State", "age", "urban_rural", "gender", "caste", "religion","Risky_Solar", "Risky_Nuclear", "Risky_Coal", "Ben_Solar","Ben_Nuclear","Ben_Coal","K_S","K_E","K_H","K_I", "DISPLACE", "POLLUTE", "HEALTH", "JOBS", "BEAUTY", "PRIDE", "NPRIDE","DEV", "PROSPER", "RELY", "WEALTHLIM", "MECHANISATION", "DECISIONDECEN", "INDUSTRYSMALL", "ECONOMYLOCAL", "ENVOVERDEV", "OWNERPUB", "OWNERREG", "DECISIONCEN","INDUSTRYLARGE","ECONOMYGLOBAL","OWNERPVT","OWNERNOREG" )))

library(dplyr)

formice <- formice1 %>%
  mutate(across(Risky_Solar:age, ~factor(.x, ordered = TRUE)))%>%
  mutate(across(urban_rural:religion, ~factor(.x, ordered = FALSE)))%>%
  mutate(across(State, ~factor(.x, ordered = FALSE)))

#str(formice)
summary(formice)

# litte's MCAR test 

sum(is.na(formice))

mcar_test(data= codedmodule2)

# p value = 1, which means MAR condition is met. 

```









# Kahan scale: MAR condition and missing data pattern 
```{r, echo=FALSE}

kahanall <- codedmodule2 %>%
          dplyr::select(c(starts_with("K_"), "age", "gender", "caste", "State", "urban_rural", "religion")) %>%
          mutate(across(gender:religion, ~factor(.x, ordered = FALSE))) %>%
          mutate(across(age, ~factor(.x, ordered = TRUE)))
          
  
str(kahanall)

md.pattern(kahanall) #the variables with missing values: K_SHARM K_IPROTECT K_IPRIVACY K_SPROTECT K_SLIMCHOI K_IINTRFER K_HEQUAL K_HREVDIS1 

mcar_test(data=kahanall) # p values is less than 0.05 - the condition for MCAR is not met 

# dataset with missing variables to compare and test group comaprisons 


MARkahan <- codedmodule2 %>%
          dplyr::select(c("K_SHARM", "K_IPROTECT", "K_IPRIVACY", "K_SPROTECT", "K_SLIMCHOI", "K_IINTRFER",  "K_HEQUAL", "K_HREVDIS1" , "age", "gender", "caste", "State", "urban_rural", "religion"))

MARkahan$K_SHARM_MAR <- MARkahan$K_SHARM

MARkahan$K_IPROTECT_MAR <- MARkahan$K_IPROTECT

MARkahan$K_SPROTECT_MAR <- MARkahan$K_SPROTECT

MARkahan$K_SLIMCHOI_MAR <- MARkahan$K_SLIMCHOI

library(finalfit)

# "K_SHARM" = "(C)Sometimes the government needs to make laws that keep people from hurting themselves.",
explanatory = c("age", "gender", "caste", "State", "urban_rural", "religion")
dependent = "K_SHARM_MAR"
MARkahan %>% 
  missing_compare(dependent, explanatory) %>% 
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"), 
        caption = "comparisons between values of responders (Not missing) and 
        non-responders (Missing) on the K_SHARM variable.") 

#   "K_IPROTECT" = "(I)It’s not the government’s business to try to protect people from themselves."
explanatory = c("age", "gender", "caste", "State", "urban_rural", "religion")
dependent = "K_IPROTECT_MAR"
MARkahan %>% 
  missing_compare(dependent, explanatory) %>% 
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"), 
        caption = "comparisons between values of responders (Not missing) and 
        non-responders (Missing) on the K_IPROTECT variable.") 

#  "K_SPROTECT" = "(C)The government should do more to advance society’s goals, even if that means limiting the freedom and choices of individuals.",
explanatory = c("age", "gender", "caste", "State", "urban_rural", "religion")
dependent = "K_SPROTECT_MAR"
MARkahan %>% 
  missing_compare(dependent, explanatory) %>% 
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"), 
        caption = "comparisons between values of responders (Not missing) and 
        non-responders (Missing) on the K_SPROTECT variable.") 


#  "K_SLIMCHOI" = "(C)The government should put limits on the choices individuals can make so they don’t get in the way of what’s good for society.",
explanatory = c("age", "gender", "caste", "State", "urban_rural", "religion")
dependent = "K_SLIMCHOI_MAR"
MARkahan %>% 
  missing_compare(dependent, explanatory) %>% 
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"), 
        caption = "comparisons between values of responders (Not missing) and 
        non-responders (Missing) on the K_SPROTECT variable.") 

```




## Mifa for Kahan scale 
```{r, echo =FALSE}


library(mifa)
library(mice)
library(psych)


mikahan <- mifa(data= kahanall,
                cov_vars  = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m = 50,
                n_pc= 2:4,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 427,)


mikahan

library(psych)

fit <- psych::fa(mikahan$cov_combined, nfactors = 2, rotate = "varimax")

print.psych(fit, sort= TRUE, cut= 0.4)


kahanfit4 <- psych::fa(mikahan$cov_combined, nfactors = 3, rotate = "varimax")

print.psych(kahanfit4, sort= TRUE, cut= 0.4)

```








## Pretty Table: FA Kahan

```{r, echo=FALSE}

library(flextable)

flex <- function(data, title=NULL, col_widths=NULL) {
  tbl <- flextable(data) %>%
           #padding(padding = 1, part = "all") %>%
           #set_table_properties(layout = "autofit") %>%
           fontsize(size=10, part="all") %>%
           set_caption(title, 
                       autonum = officer::run_autonum(seq_id = "tab", 
                                                      pre_label = "Table ", 
                                                      post_label = "\n", 
                                                      bkm = "anytable"))
  
  # If col_widths is provided, set column widths
  if(!is.null(col_widths)) {
    for(col in names(col_widths)){
      tbl <- width(tbl, j = col, width = col_widths[[col]])
    }
  }

  return(tbl)
}


rename_map <- c(
  "K_SHARM" = " (C)Sometimes the government needs to make laws that keep people from hurting themselves.",
"K_SLIMCHOI" = "(C)The government should put limits on the choices individuals can make so they don’t get in the way of what’s
good for society.",
"K_SPROTECT" = "(C)The government should do more to advance society’s goals, even if that means limiting the freedom and
choices of individuals.",
"K_HEQUAL" = "(H)We have gone too far in pushing equal rights in this country.",
"K_ERADEQ1" = "(E)We need to dramatically reduce inequalities between the rich and the poor.",
"K_EWEALTH" = "(E)Our society would be better off if the distribution of wealth was more equal.",
"K_ERADEQ2" = "(E)We need to dramatically reduce inequalities between men and women.",
"K_HREVDIS1" = "(H)Nowadays it seems like there is just as much discrimination against upper castes as there is against Dalits.",
"K_EDISCRIM" = "(E)Discrimination against minorities is still a very serious problem in our society.",
"K_IINTRFER" = "(I)The government interferes far too much in our everyday lives.",
"K_IPRIVACY" = "(I)The government should stop telling people how to live their lives.",
"K_IPROTECT" = "(I)It’s not the government’s business to try to protect people from themselves."
)


fa_table <- function(x, cut) {
  #get sorted loadings
  loadings <- fa.sort(x)$loadings %>% round(3)
  #suppress loadings
  loadings[loadings > -cut & loadings < cut] <- ""
  #get additional info  
  add_info <- cbind(x$communalities, 
                    x$uniquenesses,
                    x$complexity) %>%
    # make it a data frame
    as.data.frame() %>%
    # column names
    rename("Communality" = V1,
           "Uniqueness" = V2,
           "Complexity" = V3) %>%
    #get the item names from the vector
    rownames_to_column("item")
  
  #build table
  loadings %>%
    unclass() %>%
    as.data.frame() %>%
    rownames_to_column("item") %>%
    left_join(add_info) %>%
    mutate(
      item = if_else(item %in% names(rename_map), rename_map[item], item),
      code = names(rename_map)[match(item, rename_map)], # extracting short form
      across(where(is.numeric), round, 3)
    ) %>%
    dplyr::select(code, everything()) # reorder columns to bring code to the front
}

fa_table(fit , .4) %>%
  rename(Egalitarianism = MR1, Communitarianism = MR2, Items= item, Code= code) %>%
  flex("Table 1: EFA on adapted Cultural Cognition Scale from Kahan et al(2007)", col_widths = list(Items = 4.5, Code = 1))


```





```{r, echo = FALSE}
fit[["Vaccounted"]] %>%
  as.data.frame() %>%
  rownames_to_column("Property") %>%
  rename(Egalitarianism = MR1, Communitarianism = MR2) %>%
    mutate(across(where(is.numeric), round, 3)) %>%
    flex("Table 2: Eigenvalues and Variance Explained for Cultural Cognition Scale")
```







## checking merging of imputations  : kahan scale 

```{r, echo=FALSE}

kahan_imp <- mice(kahanall, m =5, maxit =30,  seed = 427, print = FALSE)

kahan_imp$chainMean



```

#Kahan Factor scores: mean across all imputations

```{r, echo=FALSE}

kahanallscores <- mice::complete(mice::mice(kahanall, m = 5, seed = 427, print = FALSE), "broad") 
            
kahanallscores <- kahanallscores %>%dplyr::select(-(contains(c("age", "urban_rural", "gender","caste","religion", "State"))))

str(kahanallscores)

nkahanall <- kahanallscores %>%
  rowwise() %>%
  mutate(
    K_IINTRFER_mean = mean(c_across(starts_with("K_IINTRFER"))),
    K_IPRIVACY_mean = mean(c_across(starts_with("K_IPRIVACY"))),
    K_SHARM_mean = mean(c_across(starts_with("K_SHARM"))),
    K_IPROTECT_mean = mean(c_across(starts_with("K_IPROTECT"))),
    K_SLIMCHOI_mean = mean(c_across(starts_with("K_SLIMCHOI"))),
    K_SPROTECT_mean = mean(c_across(starts_with("K_SPROTECT"))),
    K_HEQUAL_mean = mean(c_across(starts_with("K_HEQUAL"))),
    K_HREVDIS1_mean = mean(c_across(starts_with("K_HREVDIS1"))),
    K_EDISCRIM_mean = mean(c_across(starts_with("K_EDISCRIM"))),
    K_ERADEQ1_mean = mean(c_across(starts_with("K_ERADEQ1"))),
    K_ERADEQ2_mean = mean(c_across(starts_with("K_ERADEQ2"))),
    K_EWEALTH_mean = mean(c_across(starts_with("K_EWEALTH")))
  ) %>%
  ungroup()%>%
  dplyr::select(contains("_mean")) %>%
   rename_with(~ gsub("_mean$", "", .x))



nkahanfinal <- data.frame(factor.scores(nkahanall[, 1:12], fit)$scores)


```

## Kahan corelation table
```{r}

cor(nkahanall)

#before mice 
 cor.plot(kahanall %>% dplyr::select(-c("age", "gender", "caste", "State", "urban_rural", "religion")))

#after mice
 cor.plot(nkahanall)

cov(nkahanall)

```



## Kahan scater plot from EFA scores 
```{r, echo = FALSE}

nkahanfinal %>%
  ggplot(aes(MR1, MR2))+
  geom_count(aes(color = ..n.., size = ..n..))+
  guides(color = 'legend')+
  geom_hline(yintercept=0, colour="black", lwd=0.5)+
  geom_vline(xintercept=0, colour="black", lwd=0.5)+
  labs(x = "Hierarchy -Egalitarianism", y = "Individualism - Communitarianism")+
  ylim(-2,3)+
  xlim(-2,3)+
  theme_minimal() 
```

# Kahan alpha test

```{r, echo=FALSE}

KahanallHE <-nkahanall %>%
  dplyr::select(starts_with(c("K_H", "K_E")))

KahanallHE_alpha <- psych::alpha(KahanallHE, check.keys = TRUE) # alpha = 0.71	

KahanallC <-nkahanall %>%
  dplyr::select(starts_with(c("K_S")))

KahanallC_alpha <- psych::alpha(KahanallC, check.keys = TRUE) # alpha = 0.73


```


## Kahan: factor scores from 1st imputed dataset
```{r, echo=FALSE}


# extracting factor scores from mifa for 1st imputed dataset 

data_imp <- mice::complete(mice::mice(kahanall, 1, print = FALSE))
  
fct_scores <- data.frame(factor.scores(data_imp[, 1:12], fit)$scores)

plot(kahan_imp)


```

## Kahan: factor scores from second imputed dataset
```{r, echo=FALSE}


data_impk2 <- mice::complete(mice::mice(kahanall, 2, print = FALSE))
  
fct_scoresk2 <- data.frame(factor.scores(data_impk2[, 1:12], fit)$scores)


```


## Kahan: factor scores from third imputed dataset
```{r, echo=FALSE}


data_impk3 <- mice::complete(mice::mice(kahanall, 3, print = FALSE))
  
fct_scoresk3 <- data.frame(factor.scores(data_impk3[, 1:12], fit)$scores)


```


## Kahan: factor scores from fourth imputed dataset
```{r, echo=FALSE}


data_impk4 <- mice::complete(mice::mice(kahanall, 4, print = FALSE))
  
fct_scoresk4 <- data.frame(factor.scores(data_impk4[, 1:12], fit)$scores)


```


## Kahan: factor scores from fifth imputed dataset
```{r, echo=FALSE}


data_impk5 <- mice::complete(mice::mice(kahanall, 5, print = FALSE))
  
fct_scoresk5 <- data.frame(factor.scores(data_impk5[, 1:12], fit)$scores)


```
 
 
 
 
## are imputations plausible: Kahan scale - are values plausible ? 

yes all value are whole numbers between 1 and 5 

```{r, echo=FALSE}


summary(mikahan)

str(data_imp)
names(mikahan)

mikahan$mids

complete_data_first <- complete(mikahan$mids, 1)

summary(complete_data_first)

complete_data_2 <- complete(mikahan$mids, 2)

summary(complete_data_2)

complete_data_3 <- complete(mikahan$mids, 3)

summary(complete_data_3)

complete_data_4 <- complete(mikahan$mids, 4)

summary(complete_data_4)

complete_data_5 <- complete(mikahan$mids, 5)

summary(complete_data_5)
```

 




# Eco-pol scale: MAR condition and missing data pattern

```{r, echo=FALSE}

ecopoln <- formice1 %>%
  dplyr::select(
    DECISIONDECEN, DECISIONCEN, INDUSTRYSMALL, INDUSTRYLARGE,
    ECONOMYLOCAL, ECONOMYGLOBAL, ENVOVERDEV,DEVOVERENV, OWNERPVT, OWNERPUB,
    OWNERREG, OWNERNOREG, WEALTHLIM, MECHANISATION,
    DISPLACENUCLEAR,  POLLUTENUCLEAR, HEALTHNUCLEAR, JOBSNUCLEAR, BEAUTYNUCLEAR,
    PRIDENUCLEAR, NPRIDENUCLEAR, DEVNUCLEAR, PROSPERNUCLEAR,
    RELYNUCLEAR,age, urban_rural, gender, caste, religion, State
  )

md.pattern(ecopoln) #the variables with missing values: PRIDENUCLEAR PROSPERNUCLEAR JOBSNUCLEAR HEALTHNUCLEAR BEAUTYNUCLEAR POLLUTENUCLEAR DISPLACENUCLEAR RELYNUCLEAR  

mcar_test(data=ecopoln) # p values is less than 0.76 - the condition for MCAR is met 

# dataset with missing variables to compare and test group comaprisons 

MARecopol <- codedmodule2 %>%
          dplyr::select(c(DECISIONDECEN, DECISIONCEN, INDUSTRYSMALL, INDUSTRYLARGE,
    ECONOMYLOCAL, ECONOMYGLOBAL, ENVOVERDEV, OWNERPVT, OWNERPUB,
    OWNERREG, OWNERNOREG, WEALTHLIM, MECHANISATION,
    DISPLACENUCLEAR,  POLLUTENUCLEAR, HEALTHNUCLEAR, JOBSNUCLEAR, BEAUTYNUCLEAR,
    PRIDENUCLEAR, NPRIDENUCLEAR, DEVNUCLEAR, PROSPERNUCLEAR,
    RELYNUCLEAR,age, urban_rural, gender, caste, religion, State))

MARecopol$JOBSNUCLEAR_MAR <- MARecopol$JOBSNUCLEAR

MARecopol$PRIDENUCLEAR_MAR <- MARecopol$PRIDENUCLEAR


library(finalfit)

# JOBSNUCLEAR
explanatory = c("age", "gender", "caste", "State", "urban_rural", "religion")
dependent = "JOBSNUCLEAR_MAR"
MARecopol %>% 
  missing_compare(dependent, explanatory) %>% 
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"), 
        caption = "comparisons between values of responders (Not missing) and 
        non-responders (Missing) on the JOBSNUCLEAR variable.") 

# PRIDENUCLEAR
explanatory = c("age", "gender", "caste", "State", "urban_rural", "religion")
dependent = "PRIDENUCLEAR_MAR"
MARecopol %>% 
  missing_compare(dependent, explanatory) %>% 
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"), 
        caption = "comparisons between values of responders (Not missing) and 
        non-responders (Missing) on the PRIDENUCLEAR variable.") 







```









## Mifa for new eco-pol value scale : Nuclear energy

```{r, echo=FALSE}

 


miecopol <- mifa(data= ecopoln,
                cov_vars  = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m=50,
                n_pc= 2:4,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 429,)

miecopol



ecopolfit2 <- psych::fa(miecopol$cov_combined, nfactors = 2, rotate = "varimax")

print.psych(ecopolfit2, sort= TRUE, cut= 0.4)


```

#Ecopol Factor scores: mean across all imputations

```{r, echo=FALSE}

ecopolallscores <- mice::complete(mice::mice(ecopoln, m = 50, seed = 429, print = FALSE), "broad") 
            
ecopolallscores <- ecopolallscores %>%dplyr::select(-(contains(c("age", "urban_rural", "gender","caste","religion", "State"))))

#str(ecopolallscores)


necopol <- ecopolallscores %>%
  rowwise() %>%
  mutate(DEVNUCLEAR_mean = mean(c_across(starts_with("DEVNUCLEAR"))),
         PROSPERNUCLEAR_mean = mean(c_across(starts_with("PROSPERNUCLEAR"))),
         NPRIDENUCLEAR_mean = mean(c_across(starts_with("NPRIDENUCLEAR"))),
         PRIDENUCLEAR_mean = mean(c_across(starts_with("PRIDENUCLEAR"))),
         JOBSNUCLEAR_mean = mean(c_across(starts_with("JOBSNUCLEAR"))),
         ECONOMYGLOBAL_mean = mean(c_across(starts_with("ECONOMYGLOBAL"))),
         WEALTHLIM_mean = mean(c_across(starts_with("WEALTHLIM"))),
         INDUSTRYLARGE_mean = mean(c_across(starts_with("INDUSTRYLARGE"))),
         DECISIONCEN_mean = mean(c_across(starts_with("DECISIONCEN"))),
         MECHANISATION_mean = mean(c_across(starts_with("MECHANISATION"))),
         OWNERNOREG_mean = mean(c_across(starts_with("OWNERNOREG"))),
         INDUSTRYSMALL_mean = mean(c_across(starts_with("INDUSTRYSMALL"))),
         DEVOVERENV_mean = mean(c_across(starts_with("DEVOVERENV"))),
         OWNERPVT_mean = mean(c_across(starts_with("OWNERPVT"))),
         RELYNUCLEAR_mean = mean(c_across(starts_with("RELYNUCLEAR"))),
         BEAUTYNUCLEAR_mean = mean(c_across(starts_with("BEAUTYNUCLEAR"))),
         HEALTHNUCLEAR_mean = mean(c_across(starts_with("HEALTHNUCLEAR"))),
         POLLUTENUCLEAR_mean = mean(c_across(starts_with("POLLUTENUCLEAR"))),
         DISPLACENUCLEAR_mean = mean(c_across(starts_with("DISPLACENUCLEAR"))),
         ENVOVERDEV_mean = mean(c_across(starts_with("ENVOVERDEV"))),
         OWNERPUB_mean = mean(c_across(starts_with("OWNERPUB"))),
         OWNERREG_mean = mean(c_across(starts_with("OWNERREG"))),
         DECISIONDECEN_mean = mean(c_across(starts_with("DECISIONDECEN"))),
         ECONOMYLOCAL_mean = mean(c_across(starts_with("ECONOMYLOCAL")))
  ) %>%
  ungroup()%>%
  dplyr::select(contains("_mean")) %>%
   rename_with(~ gsub("_mean$", "", .x))

  
  

necopolfinal <- data.frame(factor.scores(necopol[, 1:24], ecopolfit2)$scores) 
                

```



# Eco-pol alpha test

```{r, echo=FALSE}

nPdevelop <-necopol %>%
  dplyr::select((c(BEAUTYNUCLEAR,  HEALTHNUCLEAR,  POLLUTENUCLEAR, DISPLACENUCLEAR, OWNERPUB, ENVOVERDEV)))

nPdevelop_alpha <- psych::alpha(nPdevelop, check.keys = TRUE) # alpha = 0.79	

nNdevelop <-necopol %>%
  dplyr::select((c(DEVNUCLEAR, PROSPERNUCLEAR,PRIDENUCLEAR, NPRIDENUCLEAR, JOBSNUCLEAR, ECONOMYGLOBAL,          WEALTHLIM,INDUSTRYLARGE, DECISIONCEN, MECHANISATION )))

nNdevelop_alpha <- psych::alpha(nNdevelop , check.keys = TRUE) # alpha = 0.79


```



# Eco-pol: Radar map

```{r, echo=FALSE}
library(ggplot2)
library(fmsb)

nrow(ecopolfit2$loadings)

# Extract the loadings
loadings_matrix4 <- ecopolfit2$loadings[1:24, ]

loadings_df2 <- as.data.frame(as.matrix(loadings_matrix4))

# Adding rownames to the dataframe as a new column
loadings_df2 <- loadings_df2 %>%
  rownames_to_column(var = "variable") 

# Pivot to longer format first
long_loadings_df2 <- loadings_df2 %>%
  pivot_longer(cols = c(MR1, MR2), names_to = "Factors", values_to = "value")

# Pivot the longer format to wide format
wide_loadings_df2 <- long_loadings_df2 %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  mutate(Factors = case_when(
    Factors == "MR1" ~ "Nationalist Development (Ndevelop)",
    Factors == "MR2" ~ "People Centered Development (Pdevelop)",
    TRUE ~ Factors
  )) %>%
  column_to_rownames("Factors")


# Define the variable ranges: maximum and minimum
max_min2 <- data.frame(
  DEVNUCLEAR = c(0.8, -0.6), PROSPERNUCLEAR = c(0.8, -0.6), NPRIDENUCLEAR = c(0.8, -0.6), PRIDENUCLEAR = c(0.8, -0.6),     JOBSNUCLEAR = c(0.8, -0.6), ECONOMYGLOBAL = c(0.8, -0.6), WEALTHLIM = c(0.8, -0.6), INDUSTRYLARGE = c(0.8, -0.6),   DECISIONCEN = c(0.8, -0.6), MECHANISATION = c(0.8, -0.6), OWNERNOREG = c(0.8, -0.6), INDUSTRYSMALL = c(0.8, -0.6), DEVOVERENV = c(0.8, -0.6), OWNERPVT = c(0.8, -0.6), RELYNUCLEAR = c(0.8, -0.6), BEAUTYNUCLEAR = c(0.8, -0.6), HEALTHNUCLEAR = c(0.8, -0.6), POLLUTENUCLEAR = c(0.8, -0.6), DISPLACENUCLEAR = c(0.8, -0.6), DECISIONDECEN = c(0.8, -0.6),
ECONOMYLOCAL = c(0.8, -0.6), ENVOVERDEV = c(0.8, -0.6), OWNERPUB = c(0.8, -0.6), OWNERREG = c(0.8, -0.6)   
)
rownames(max_min2) <- c("Max", "Min")

# Assuming you have a dataframe 'exam_scores' with matching column names
# Bind the variable ranges to the data

radar4 <- rbind(max_min2, wide_loadings_df2) %>%
    rename(
      "National development(nuclear)" = "DEVNUCLEAR",
      "Local prosperity(nuclear)" = "PROSPERNUCLEAR",
      "National pride(nuclear)" = "NPRIDENUCLEAR",
      "Community pride(nuclear)" = "PRIDENUCLEAR",
      "Job opportunities(nuclear)" = "JOBSNUCLEAR",
      "Pro Globaleconomy" = "ECONOMYGLOBAL",
      "Limits on Wealth " = "WEALTHLIM",
      "Pro Large Industries" = "INDUSTRYLARGE",
      "Pro Centralisation" = "DECISIONCEN",
      "Anti Mechanisation of work" = "MECHANISATION",
      "Anti Regulations" = "OWNERNOREG",
      "Anti Large Industries " = "INDUSTRYSMALL",
      "Development over Environment" = "DEVOVERENV",
      "Pro Private ownership " = "OWNERPVT",
      "Less Reliance on government(nuclear)" = "RELYNUCLEAR",
      "Spoils Natural Beauty(nuclear)" = "BEAUTYNUCLEAR",
      "Health risk(nuclear)" = "HEALTHNUCLEAR",
      "Pollution risk(nuclear) " = "POLLUTENUCLEAR",
      "Displacement risk(nuclear)" = "DISPLACENUCLEAR",
      "Environment over Development" = "ENVOVERDEV",
      "Pro Public ownership" = "OWNERPUB",
      "Pro Regulations" = "OWNERREG",
      "Pro Decentralisation" = "DECISIONDECEN",
      "Pro Localeconomy" = "ECONOMYLOCAL",
    )

```


```{r, echo=FALSE, fig.width=20, fig.height=18, out.width='70', out.height='70'}
library(fmsb)

create_beautiful_radarchart <- function(data, color = "#00AFBB", 
                                        vlabels = colnames(data), vlcex = 0.7,
                                        caxislabels = NULL, title = NULL, ...){
  radarchart(
    data, axistype = 1,
    # Customize the polygon
    pcol = color, pfcol = scales::alpha(color, 0.7), plwd = 2, plty = 1,
    centerzero=FALSE,
    # Customize the grid
    cglcol = "grey", cglty = 1, cglwd = 2,
    # Customize the axis
    axislabcol = "black", cexc = 7, # Increase label size for axis
    # Variable labels
    vlcex = vlcex, vlabels = vlabels, vlpos = 0.98,
    seg = 7, caxislabels = caxislabels, title = title, 
    # Increase title size
    cex.main = 4,
    ...
  )
}


# Reduce plot margin using par()
op <- par(mar = c(7, 3, 3, 3))
# Create the radar charts
create_beautiful_radarchart(
  data = radar4, caxislabels = c(-0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8),
  color = c( "#F97D09","#00AFBB"),
  vlcex = 1.1
)

# Add an horizontal legend
legend(
  x = "bottomright", legend = rownames(radar4[-c(1,2),]), horiz = TRUE,
  bty = "n", pch = 20 , col = c("#F97D09","#00AFBB"),
  text.col = "black", cex = 1.5, pt.cex = 3,
  inset = c(0, 0)
  )
par(op)

```


# Pretty table: Nuclear EFA

```{r, echo=FALSE}

library(flextable)

flex <- function(data, title=NULL, col_widths=NULL) {
  tbl <- flextable(data) %>%
           #padding(padding = 1, part = "all") %>%
           #set_table_properties(layout = "autofit") %>%
           fontsize(size=10, part="all") %>%
           set_caption(title, 
                       autonum = officer::run_autonum(seq_id = "tab", 
                                                      pre_label = "Table ", 
                                                      post_label = "\n", 
                                                      bkm = "anytable"))
  
  # If col_widths is provided, set column widths
  if(!is.null(col_widths)) {
    for(col in names(col_widths)){
      tbl <- width(tbl, j = col, width = col_widths[[col]])
    }
  }

  return(tbl)
}


rename_map2 <- c(
  "WEALTHLIM" = "A limit should be put to how much wealth a person can amass",
  "MECHANISATION" = "Rapid mechanization of work is taking away jobs from workers in this country",
  "DECISIONDECEN" = "Local politicians shouldn't have to ask permission from the central government to implement policies",
  "DECISIONCEN" = "Laws and policies would be implemented more smoothly if more power lay with the central government",
  "INDUSTRYLARGE" = "Large scale industries are required for the development of the country that will benefit everyone",
  "INDUSTRYSMALL" = "Large corporations are destroying the local industries in India and benefiting only a handful of people",
  "ECONOMYGLOBAL" = "Foreign companies have led to a range of benefits for the Indian people and society",
  "ECONOMYLOCAL" = "India would be better off if foreign companies didn't come to here",
  "ENVOVERDEV" = "Polluting industries that spoil the environment should be shut down even if it costs people their jobs",
  "DEVOVERENV" = "Economic growth and creating jobs should be prioritized over environmental protection",
  "OWNERPVT" = "All businesses and industries should be owned privately",
  "OWNERNOREG" = "There is too much red-tape and the government should not interfere with businesses and industries",
  "OWNERPUB" = "The government should own most large businesses and industries",
  "OWNERREG" = "Regardless of ownership, the government should pass strong regulations and implement them",
  "DISPLACENUCLEAR" = "Nuclear energy is leading to displacement of people from their land",
  "BEAUTYNUCLEAR" = "Nuclear energy spoils the natural beauty of the landscape",
  "POLLUTENUCLEAR" = "Nuclear energy increases pollution of air/water/land",
  "HEALTHNUCLEAR" = "Nuclear energy poses a great risk to the health of people living around it",
  "JOBSNUCLEAR" = "Nuclear energy will bring jobs to the local community",
  "PRIDENUCLEAR" = "I would be proud if my community used nuclear energy",
  "NPRIDENUCLEAR" = "Nuclear energy is a mark of pride for our nation",
  "DEVNUCLEAR" = "Nuclear energy pushes forward the country's development",
  "PROSPERNUCLEAR" = "Nuclear energy brings economic prosperity to the surrounding regions",
  "RELYNUCLEAR" = "I don't like the idea that I have to rely on the government for electricity from nuclear energy"
)


fa_table <- function(x, cut) {
  #get sorted loadings
  loadings <- fa.sort(x)$loadings %>% round(3)
  #suppress loadings
  loadings[loadings > -cut & loadings < cut] <- ""
  #get additional info  
  add_info <- cbind(x$communalities, 
                    x$uniquenesses,
                    x$complexity) %>%
    # make it a data frame
    as.data.frame() %>%
    # column names
    rename("Communality" = V1,
           "Uniqueness" = V2,
           "Complexity" = V3) %>%
    #get the item names from the vector
    rownames_to_column("item")
  
  #build table
  loadings %>%
    unclass() %>%
    as.data.frame() %>%
    rownames_to_column("item") %>%
    left_join(add_info) %>%
    mutate(
      item = if_else(item %in% names(rename_map2), rename_map2[item], item),
      code = names(rename_map2)[match(item, rename_map2)], # extracting short form
      across(where(is.numeric), round, 3)
    ) %>%
    dplyr::select(code, everything()) # reorder columns to bring code to the front
}

fa_table(ecopolfit2, .4) %>%
  rename(Ndevelop = MR1, Pdevelop = MR2, Items= item) %>%
  dplyr::mutate(code = case_when(
    code == "WEALTHLIM" ~ "Limits on Wealth",
    code == "MECHANISATION" ~ "Anti Mechanisation of work",
    code == "DECISIONDECEN" ~ "Pro Decentralisation",
    code == "DECISIONCEN" ~ "Pro Centralisation",
    code == "INDUSTRYLARGE" ~ "Pro Large Industries",
    code == "INDUSTRYSMALL" ~ "Anti Large Industries",
    code == "ECONOMYGLOBAL" ~ "Pro Globaleconomy",
    code == "ECONOMYLOCAL" ~ "Pro Localeconomy",
    code == "ENVOVERDEV" ~ "Environment over Development",
    code == "DEVOVERENV" ~ "Development over Environment",
    code == "OWNERPVT" ~ "Pro Private ownership",
    code == "OWNERNOREG" ~ "Anti Regulations",
    code == "OWNERPUB" ~ "Pro Public ownership",
    code == "OWNERREG" ~ "Pro Regulations",
    code == "DISPLACENUCLEAR" ~ "Displacement risk(nuclear)",
    code == "POLLUTENUCLEAR" ~ "Pollution risk(nuclear)",
    code == "HEALTHNUCLEAR" ~ "Health risk(nuclear)",
    code == "JOBSNUCLEAR" ~ "Job opportunities(nuclear)",
    code == "BEAUTYNUCLEAR" ~ "Spoils Natural Beauty(nuclear)",
    code == "PROSPERNUCLEAR" ~ "Local prosperity(nuclear)",
    code == "PRIDENUCLEAR" ~ "Community pride(nuclear)",
    code == "NPRIDENUCLEAR" ~ "National pride(nuclear)",
    code == "DEVNUCLEAR" ~ "National development(nuclear)",
    code == "RELYNUCLEAR" ~ "Less Reliance on government(nuclear)",
    TRUE ~ code # Default case to keep original value if no match
  )) %>%
  flex("Table 3: EFA on Eco-Pol Values Scale", col_widths = list(Items = 4.5, code = 1.5))


```










```{r, echo = FALSE}
ecopolfit2[["Vaccounted"]] %>%
  as.data.frame() %>%
  rownames_to_column("Property") %>%
  rename(Ndevelop = MR1, Pdevelop = MR2) %>%
    mutate(across(where(is.numeric), round, 3)) %>%
    flex("Table 4: Eigenvalues and Variance Explained Eco-Pol Scale")
```



```{r, echo=FALSE}

# Extracting factors from first imputed dataset

data_imp2 <- mice::complete(mice::mice(ecopoln, 1, print = FALSE))
  
fct_scores2 <- data.frame(factor.scores(data_imp2[, 1:24], ecopolfit2)$scores)

```

##  eco-pol scale : Factor scores from 2nd imputation
```{r, echo=FALSE}

data_impe2 <- mice::complete(mice::mice(ecopoln, 2, print = FALSE))
  
fct_scorese2 <- data.frame(factor.scores(data_impe2[, 1:24], ecopolfit2)$scores)

```



##  eco-pol scale : Factor scores from 3rd imputation
```{r, echo=FALSE}

data_impe3 <- mice::complete(mice::mice(ecopoln, 3, print = FALSE))
  
fct_scorese3 <- data.frame(factor.scores(data_impe3[, 1:24], ecopolfit2)$scores)

```


##  eco-pol scale : Factor scores from 4th imputation
```{r, echo=FALSE}

data_impe4 <- mice::complete(mice::mice(ecopoln, 4, print = FALSE))
  
fct_scorese4 <- data.frame(factor.scores(data_impe4[, 1:24], ecopolfit2)$scores)

```

##  eco-pol scale : Factor scores from 5th imputation
```{r, echo=FALSE}

data_impe5 <- mice::complete(mice::mice(ecopoln, 5, print = FALSE))
  
fct_scorese5 <- data.frame(factor.scores(data_impe5[, 1:24], ecopolfit2)$scores)

```


## Are imputations plausible : Eco-pol scale

yes, imputations are pluasible- all natural numbers between 1 and 5 

```{r, echo=FALSE}


summary(miecopol)
names(miecopol)

miecopol$mids

complete_ecopol_first <- complete(miecopol$mids, 1)

summary(complete_ecopol_first)

complete_ecopol_2 <- complete(miecopol$mids, 2)

summary(complete_ecopol_2)

complete_ecopol_3 <- complete(miecopol$mids, 3)

summary(complete_ecopol_3)

complete_ecopol_4 <- complete(miecopol$mids, 4)

summary(complete_ecopol_4)

complete_ecopol_5 <- complete(miecopol$mids, 5)

summary(complete_ecopol_5)



```


# Checking consistency of LM coefficients across 5 imputed datasets 
coefficients and LMs are fairly consistent

## Binding datasets: 1st imputation 

```{r, echo = FALSE}

# binding the imputed  factor analysis scores for kahan scale and eco-pol value scale to the larger dataset codedmodule2

ecopolnuclear <- fct_scores2 %>%
  rename(Ndevelop = MR1, Pdevelop = MR2)

kahannuclear <- fct_scores%>%
  rename(Egalitarian = MR1, Communitarian = MR2)


allformice<- cbind(formice1,ecopolnuclear, kahannuclear)

```


## State Ns before MIFA

```{r, echo=FALSE}
Statenacheck1 <- allformice%>%
  na.omit()%>%
  dplyr::select(State)

summary(Statenacheck1)
```


```{r, echo=FALSE}

# Allformice: Do imputations merge ? 


# Initialize the mice process to create the predictor matrix
#ini <- mice(allformice, maxit = 0, pri = FALSE)

# Extract the predictor matrix from the initialized object
#pred <- ini$predictorMatrix

# Set the columns for "Uppercaste", "Male", "Hindu", and "Age" to 0
#pred[, "Uppercaste"] <- 0
#pred[, "Male"] <- 0
#pred[, "Hindu"] <- 0
#pred[, "Age"] <- 0
#pred[, "Ndevelop"] <- 0
#pred[, "Pdevelop"] <- 0
#pred[, "Egalitarian"] <- 0
#pred[, "Communitarian"] <- 0
# Identify columns that start with "K_" and set them to 0
#k_columns <- grep("^K_", colnames(formice1))
#pred[, k_columns] <- 0

# Perform the mice imputation with the updated predictor matrix
#allformice.imp <- mice(allformice, m = 5, maxit = 10, predictorMatrix = pred, seed = 430, print = TRUE)

#summary(allformice.imp)
#allformice.imp$chainMean


#plot(allformice.imp)

```


## State Ns after MIFA on two scales

```{r, echo=FALSE}

nuclear_missing <- allformice %>% dplyr::select(Risky_Nuclear,Uppercaste, Male, Hindu, urban_rural, Age, State)%>%
  na.omit()

summary(nuclear_missing)

```


## LMs with 1st imputed datasets from FAs 

```{r, echo=FALSE}

nuclearIVmice <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State, data = allformice)


nuclearIVmice2 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian, data = allformice)

nuclearIVmice3 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian + Pdevelop + Ndevelop, data = allformice)

summary(nuclearIVmice)
summary(nuclearIVmice2)
summary(nuclearIVmice3)


```

## binding dataset - 2nd imputation

```{r, echo=FALSE}

ecopolnuclear2 <- fct_scorese2 %>%
  rename(Ndevelop = MR1, Pdevelop = MR2)

kahannuclear2 <- fct_scoresk2%>%
  rename(Egalitarian = MR1, Communitarian = MR2)

allformice2<- cbind(formice1,ecopolnuclear2, kahannuclear2)

```

## LMs with second imputation 
```{r, echo=FALSE}

nuclearIVmiceimp2 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State, data = allformice2)

nuclearIVmiceimp22 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian, data = allformice2)

nuclearIVmiceimp23 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian + Pdevelop + Ndevelop, data = allformice2)

summary(nuclearIVmiceimp2)
summary(nuclearIVmiceimp22)
summary(nuclearIVmiceimp23)

```



## binding dataset - 3rd imputation

```{r, echo=FALSE}

ecopolnuclear3 <- fct_scorese3 %>%
  rename(Ndevelop = MR1, Pdevelop = MR2)

kahannuclear3 <- fct_scoresk3%>%
  rename(Egalitarian = MR1, Communitarian = MR2)

allformice3<- cbind(formice1,ecopolnuclear3, kahannuclear3)

```

## LMs with third imputation 
```{r, echo=FALSE}

nuclearIVmiceimp3 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State, data = allformice3)

nuclearIVmiceimp32 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian, data = allformice3)

nuclearIVmiceimp33 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian + Pdevelop + Ndevelop, data = allformice3)

summary(nuclearIVmiceimp3)
summary(nuclearIVmiceimp32)
summary(nuclearIVmiceimp33)

```

## binding dataset - 4th imputation

```{r, echo=FALSE}

ecopolnuclear4 <- fct_scorese4 %>%
  rename(Ndevelop = MR1, Pdevelop = MR2)

kahannuclear4 <- fct_scoresk4%>%
  rename(Egalitarian = MR1, Communitarian = MR2)

allformice4<- cbind(formice1, ecopolnuclear4, kahannuclear4)

```

## LMs with fourth imputation 
```{r, echo=FALSE}

nuclearIVmiceimp4 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State, data = allformice4)

nuclearIVmiceimp24 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian, data = allformice4)

nuclearIVmiceimp34 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian + Pdevelop + Ndevelop, data = allformice4)

summary(nuclearIVmiceimp4)
summary(nuclearIVmiceimp24)
summary(nuclearIVmiceimp34)

```


# Mean across imputations 

## Binding datasets 

```{r, echo = FALSE}

# binding the imputed  factor analysis scores for kahan scale and eco-pol value scale to the larger dataset codedmodule2

ecopolnuclearfinal <- necopolfinal %>%
  rename(Ndevelop = MR1, Pdevelop = MR2)

kahannuclearfinal <- nkahanfinal%>%
  rename(Egalitarian = MR1, Communitarian = MR2)


allformicefinal<- cbind(formice1,ecopolnuclearfinal, kahannuclearfinal)

```


## LMs with final imputed datasets from FAs 

```{r, echo=FALSE}


allformicefinal$State <- factor(allformicefinal$State, levels = c("Maharashtra","West Bengal" ,"Rajasthan","Tamil Nadu",  "Uttar Pradesh"))


nuclearfinal <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age, data = allformicefinal)


nuclearfinal2 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State, data = allformicefinal)


nuclearfinal3 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian, data = allformicefinal)

nuclearfinal4 <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian + Egalitarian + Pdevelop + Ndevelop, data = allformicefinal)

summary(nuclearfinal)
summary(nuclearfinal2)
summary(nuclearfinal3)
summary(nuclearfinal4)

aic_values <- AIC(nuclearfinal, nuclearfinal2, nuclearfinal3, nuclearfinal4)

print(aic_values)

bic_values <- BIC(nuclearfinal, nuclearfinal2, nuclearfinal3, nuclearfinal4)

print(bic_values)

```


# correlation table 

```{r}

nforcor <- allformicefinal %>%
           dplyr::select(Risky_Nuclear, Communitarian , Egalitarian , Pdevelop , Ndevelop)

cor.plot(nforcor)
```

# interaction vars

```{r}

nuclearinterac <- lm(Risky_Nuclear ~ Uppercaste + Male + Hindu + urban_rural + Age + State + Communitarian*State + Egalitarian*State + Pdevelop*State + Ndevelop*State , data = allformicefinal)

summary(nuclearinterac)

```
\newpage






```{r, echo=FALSE, results='asis'}
library(stargazer)


#cat("\\begingroup")
#cat("\\setlength{\\tabcolsep}{1pt}")
#cat("\\renewcommand{\\arraystretch}{0.7}")
stargazer(nuclearfinal, nuclearfinal2, nuclearfinal3, nuclearfinal4, nuclearinterac,
          title = "Table 6: 5 linear models: Perceived Risk of Nuclear Energy",
          type = "text"
)
#cat("\\endgroup")


```



# NUCLEAR2 : only charcateristics of tech


```{r, echo=FALSE}

ecopoln2 <- formice1 %>%
  dplyr::select(
    DISPLACENUCLEAR,  POLLUTENUCLEAR, HEALTHNUCLEAR, JOBSNUCLEAR, BEAUTYNUCLEAR,
    PRIDENUCLEAR, NPRIDENUCLEAR, DEVNUCLEAR, PROSPERNUCLEAR,
    RELYNUCLEAR, age, urban_rural, gender, caste, religion, State
  )


str(ecopoln2)
md.pattern(ecopoln2) #the variables with missing values:  

mcar_test(data=ecopoln2)
```


# Nuclear2 : Mifa for new eco-pol value scale

```{r, echo=FALSE}



miecopoln2 <- mifa(data= ecopoln2,
                cov_vars = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m=10,
                n_pc= 2:4,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 528,)

miecopoln2



ecopolfitn2 <- psych::fa(miecopoln2$cov_combined, nfactors = 2, rotate = "varimax")

print.psych(ecopolfitn2, sort= TRUE, cut= 0.4)


```




# Solar : MAR condition and missing data pattern


```{r, echo=FALSE}

ecopols <- formice1 %>%
  dplyr::select(
    DECISIONDECEN, DECISIONCEN, INDUSTRYSMALL, INDUSTRYLARGE,
    ECONOMYLOCAL, ECONOMYGLOBAL, ENVOVERDEV,DEVOVERENV, OWNERPVT, OWNERPUB,
    OWNERREG, OWNERNOREG, WEALTHLIM, MECHANISATION,
    DISPLACESOLAR,  POLLUTESOLAR, HEALTHSOLAR, JOBSSOLAR, BEAUTYSOLAR,
    PRIDESOLAR, NPRIDESOLAR, DEVSOLAR, PROSPERSOLAR,
    RELYSOLAR,age, urban_rural, gender, caste, religion, State
  )

md.pattern(ecopols) #the variables with missing values:  

mcar_test(data=ecopols)
```


# Solar : Mifa for new eco-pol value scale

```{r, echo=FALSE}

 


miecopols <- mifa(data= ecopols,
                cov_vars  = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m=5,
                n_pc= 1:2,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 528,)

miecopols



ecopolfits <- psych::fa(miecopols$cov_combined, nfactors = 2, rotate = "varimax")

print.psych(ecopolfits, sort= TRUE, cut= 0.4)



```

# Solar 2 : only charcateristics of tech


```{r, echo=FALSE}

ecopols2 <- formice1 %>%
  dplyr::select(
    DISPLACESOLAR,  POLLUTESOLAR, HEALTHSOLAR, JOBSSOLAR, BEAUTYSOLAR,
    PRIDESOLAR, NPRIDESOLAR, DEVSOLAR, PROSPERSOLAR,
    RELYSOLAR, age, urban_rural, gender, caste, religion, State
  )


str(ecopols2)
md.pattern(ecopols2) #the variables with missing values:  

mcar_test(data=ecopols2)
```


# SOLAR2 : Mifa for new eco-pol value scale

```{r, echo=FALSE}



miecopols2 <- mifa(data= ecopols2,
                cov_vars = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m=10,
                n_pc= 2:4,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 528,)

miecopols2



ecopolfits2 <- psych::fa(miecopols2$cov_combined, nfactors = 2, rotate = "varimax")

print.psych(ecopolfits2, sort= TRUE, cut= 0.4)


```




# Solar: Mifa with CFA

```{r}




## CFA on ecopol vars for solar energy 

ecopols_2fa <- '
  Ndevelop =~ DEVSOLAR + PRIDESOLAR + NPRIDESOLAR + PROSPERSOLAR + JOBSSOLAR 
  Pdevelop =~ HEALTHSOLAR + BEAUTYSOLAR + DISPLACESOLAR + POLLUTESOLAR + ENVOVERDEV
'

secopol_cfa <- cfa(ecopols_2fa, data = miecopols$cov_combined, std.lv = TRUE)
summary(secopol_cfa, fit.measure= TRUE, standardized = TRUE)



```



# COAL : MAR condition and missing data pattern


```{r, echo=FALSE}

ecopolc <- formice1 %>%
  dplyr::select(
    DECISIONDECEN, DECISIONCEN, INDUSTRYSMALL, INDUSTRYLARGE,
    ECONOMYLOCAL, ECONOMYGLOBAL, ENVOVERDEV,DEVOVERENV, OWNERPVT, OWNERPUB,
    OWNERREG, OWNERNOREG, WEALTHLIM, MECHANISATION,
    DISPLACECOAL,  POLLUTECOAL, HEALTHCOAL, JOBSCOAL, BEAUTYCOAL,
    PRIDECOAL, NPRIDECOAL, DEVCOAL, PROSPERCOAL,
    RELYCOAL,age, urban_rural, gender, caste, religion, State
  )

md.pattern(ecopolc) #the variables with missing values:  

mcar_test(data=ecopolc)
```







# Coal : Mifa for new eco-pol value scale

```{r, echo=FALSE}

 


miecopolc <- mifa(data= ecopolc,
                cov_vars  = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m=50,
                n_pc= 2:4,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 528,)

miecopolc



ecopolfitc <- psych::fa(miecopolc$cov_combined, nfactors = 3, rotate = "varimax")

print.psych(ecopolfitc, sort= TRUE, cut= 0.4)


```



# COAL2 : only charcateristics of tech


```{r, echo=FALSE}

ecopolc2 <- formice1 %>%
  dplyr::select(
    DISPLACECOAL,  POLLUTECOAL, HEALTHCOAL, JOBSCOAL, BEAUTYCOAL,
    PRIDECOAL, NPRIDECOAL, DEVCOAL, PROSPERCOAL,
    RELYCOAL,age, urban_rural, gender, caste, religion, State
  )

md.pattern(ecopolc2) #the variables with missing values:  

mcar_test(data=ecopolc2)
```


# Coal2 : Mifa for new eco-pol value scale

```{r, echo=FALSE}

 


miecopolc2 <- mifa(data= ecopolc2,
                cov_vars  = -c("age", "gender", "caste", "State", "urban_rural", "religion"),
                m=5,
                n_pc= 2:4,
                ci = "fieller", 
                n_boot=1000,
                print = FALSE,
                progress= TRUE, 
                seed = 528,)

miecopolc2



ecopolfitc2 <- psych::fa(miecopolc2$cov_combined, nfactors = 2, rotate = "varimax")

print.psych(ecopolfitc2, sort= TRUE, cut= 0.4)


```







```{r}

cor.plot(ecopolc %>% dplyr::select(-c("age", "gender", "caste", "State", "urban_rural", "religion")))
```



# Coal: Mifa with CFA

```{r}



# (DECISIONDECEN, DECISIONCEN, INDUSTRYSMALL, INDUSTRYLARGE,ECONOMYLOCAL, ECONOMYGLOBAL, ENVOVERDEV,DEVOVERENV, OWNERPVT, OWNERPUB,OWNERREG, OWNERNOREG, WEALTHLIM, MECHANISATION,DISPLACECOAL,  POLLUTECOAL, HEALTHCOAL, JOBSCOAL, BEAUTYCOAL,PRIDECOAL, NPRIDECOAL, DEVCOAL, PROSPERCOAL,RELYCOAL)

 


## CFA on ecopol vars for coal 

ecopolc_2fa <- '
  Pride =~ PRIDECOAL + NPRIDECOAL + DEVOVERENV +  DECISIONCEN + OWNERPVT + DECISIONCEN  + OWNERNOREG + ECONOMYGLOBAL
  Social Costs =~ BEAUTYCOAL + POLLUTECOAL + HEALTHCOAL
  Social Costs2 =~ OWNERPUB + ENVOVERDEV + DISPLACECOAL
  
'

cecopol_cfa <- cfa(ecopolc_2fa, data = miecopolc$cov_combined, std.lv = TRUE)
summary(cecopol_cfa, fit.measure= TRUE, standardized = TRUE)



```


```{r, echo=FALSE}

# LM with demographic variables and State 
# The pool() function from the mice package creates a list containing the results,
# so we need to access the summary of the model directly.

#pooled_fit4 <- pool(nuclearfit4)

#pooled_summary4 <- summary(pooled_fit4)

#coefficients_df4 <- pooled_summary4
# To ensure the numeric values are rounded to two decimal places, you can use:
#coefficients_df4 <- round(coefficients_df4[, -1], 2)  # Skipping the first column as it's factors (term names)
#coefficients_df4$term <- pooled_summary4$term  # Adding back the unrounded terms

# Print the dataframe
#data.frame(coefficients_df4) %>%
 # dplyr::select(term, estimate, std.error, statistic, df, p.value)
```